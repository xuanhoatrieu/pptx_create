**Slide 1: Title Slide**

* **Title:** Chương 3 (Phần cuối): Tầng Ứng dụng (Application Layer)
* **Subtitle:** Nơi Mạng máy tính Gặp gỡ Người dùng
* **[Visual Idea]:** Một hình ảnh đồ họa cách điệu, trong đó một người dùng đang tương tác với một màn hình cảm ứng lớn. Từ màn hình đó, các icon của các ứng dụng quen thuộc (HTTP, SMTP, DNS, FTP) tỏa ra và kết nối với một đám mây mạng lưới phức tạp ở phía sau. Điều này thể hiện Tầng Ứng dụng là giao diện giữa con người và hạ tầng mạng.
* **[Speaker Notes]:** "Chào mừng các em đến với bài học cuối cùng của Chương 3, và cũng là bài học khép lại toàn bộ môn học. Chúng ta đã cùng nhau trải qua một hành trình dài, bắt đầu từ những tín hiệu điện, đi qua các khung dữ liệu, các gói tin, và các phân đoạn dữ liệu.
Hôm nay, chúng ta sẽ bước lên tầng cao nhất – Tầng Ứng dụng. Đây chính là tầng mà chúng ta tương tác hằng ngày, dù nhiều khi không hề nhận ra. Chính tại tầng này, các giao thức như ết-ti-ti-pi, ép-ti-pi... đã tạo nên thế giới web, thư điện tử, trò chuyện trực tuyến và vô số dịch vụ số khác mà chúng ta đang sử dụng hàng ngày trên In-tơ-nét."

**Slide 2: Table of Contents**

* **Title:** Nội dung bài học
* **Content:**
    * 1: Khái niệm Cốt lõi (Client/Server, Socket)
    * 2: HTTP/HTTPS - Ngôn ngữ của World Wide Web
    * 3: DNS - "Danh bạ" của Internet
    * 4: FTP - Chuyên gia Truyền tải Tập tin
    * 5: Hệ thống Email (SMTP, POP3, IMAP)
* **[Visual Idea]:** Một sơ đồ tư duy (mind map) với "Tầng Ứng dụng" ở trung tâm. Từ đó tỏa ra 5 nhánh chính, mỗi nhánh có một icon đặc trưng: một icon hai máy tính kết nối (Client/Server), logo quả địa cầu (HTTP), logo quyển danh bạ (DNS), logo thư mục (FTP), và logo lá thư (Email).
* **[Speaker Notes]:** "Trong bài học này, chúng ta sẽ bắt đầu với các khái niệm nền tảng của Tầng Ứng dụng – tầng cao nhất trong mô hình mạng, nơi các ứng dụng mà chúng ta sử dụng hằng ngày thực sự vận hành.
Sau đó, chúng ta sẽ lần lượt khám phá những giao thức quan trọng nhất đã định hình nên In-tơ-nét bao gồm: ết-ti-ti-pi  cho việc truy cập web, Đi-en-ét cho việc tìm kiếm, Ép-ti-pi cho việc truyền tệp giữa các máy tính và cuối cùng là bộ ba giao thức cho hệ thống i-mêu."

**Slide 3: Learning Objectives**

* **Title:** Mục tiêu bài học
* **Content:**
    * **Trình bày được** vai trò của Tầng Ứng dụng và kiến trúc Client/Server.
    * **Phân tích được** nguyên lý hoạt động của HTTP, bao gồm các loại kết nối và khuôn dạng thông điệp.
    * **Giải thích được** hệ thống DNS phân cấp và chức năng của các loại bản ghi chính.
    * **So sánh được** cơ chế hoạt động của SMTP, POP3, và IMAP.
* **[Visual Idea]:** Bốn khối thông tin được thiết kế như các "thẻ thành tựu". Mỗi thẻ có một mục tiêu được in đậm và một hình ảnh minh họa chi tiết: một sơ đồ client-server, một sơ đồ thông điệp HTTP request/response, một sơ đồ cây phân cấp của DNS, và một sơ đồ so sánh 3 giao thức email.
* **[Speaker Notes]:** "Kết thúc bài học, thầy kỳ vọng các em sẽ nắm vững các mục tiêu sau: trình bày được các khái niệm cơ bản, phân tích sâu được giao thức quan trọng nhất là HTTP, giải thích được hệ thống phức tạp nhưng hiệu quả của DNS, và so sánh được các giao thức email để biết khi nào nên dùng cái nào."

**Slide 4: Introduction Scenario**

* **Title:** Tình huống
* **Content:**
    * An muốn gửi file báo cáo lớn cho giáo viên qua email.
    * **Chuỗi hành động:** Mở trình duyệt -> Truy cập Gmail -> Soạn thư -> Đính kèm file -> Nhấn "Gửi".
    * **Câu hỏi:** Đằng sau sự đơn giản đó, những giao thức nào đã phối hợp với nhau?
* **[Visual Idea]:** Một infographic dạng timeline hoặc flowchart. Bắt đầu với icon người dùng (An). Mũi tên chỉ đến icon trình duyệt Chrome. Bên dưới ghi "Gõ mail.google.com". Mũi tên tiếp theo chỉ đến icon Gmail. Bên dưới ghi "Đăng nhập, soạn thư, gửi". Mũi tên cuối cùng chỉ đến icon giáo viên đang mở laptop. Dọc theo các mũi tên là các dấu hỏi chấm lớn.
* **[Speaker Notes]:** "Hãy bắt đầu bài học hôm nay bằng một tình huống rất thực tế và quen thuộc.
Bạn An gửi một tệp tin cho giáo viên qua Gmail. Với người dùng, quá trình này có vẻ rất đơn giản — chỉ cần vài cú nhấp chuột: soạn thư, đính kèm file, rồi nhấn "Gửi".
Nhưng phía dưới bề mặt, trong thế giới vô hình của mạng máy tính, đang diễn ra một “sự phối hợp nhịp nhàng như một dây chuyền hoạt động tinh vi” giữa nhiều giao thức tầng ứng dụng:
Đi-en-ét giúp trình duyệt tìm đúng địa chỉ ai-pi của máy chủ Gmail.
Ết-ti-ti-pi cho phép An tải giao diện Gmail và gửi dữ liệu qua web.
Và cuối cùng, Ét-em-ti-pi chịu trách nhiệm vận chuyển thư điện tử của An đến hộp thư của giáo viên.
Vậy các giao thức này liên kết với nhau ra sao, làm cách nào để một hành động đơn giản của người dùng lại khởi động cả một chuỗi tiến trình tinh vi như vậy?
Trong bài học hôm nay, chúng ta sẽ cùng nhau giải đáp câu hỏi này."

**Slide 5: Vai trò Tầng Ứng dụng**

* **Title:** 1.1. Tầng Ứng dụng - Giao diện của Mạng
* **Content:**
    * Là tầng cao nhất trong mô hình mạng.
    * Là nơi các ứng dụng mạng (trình duyệt, email client...) và người dùng tương tác.
    * **Giao thức Tầng Ứng dụng:** Định nghĩa "luật chơi" cho việc trao đổi thông điệp giữa các ứng dụng.
* **[Visual Idea]:** Một sơ đồ các tầng mạng dạng lát cắt. Tầng Ứng dụng ở trên cùng được tô màu rực rỡ và có các icon ứng dụng quen thuộc. Các tầng dưới (Transport, Network...) được làm mờ dần, thể hiện sự trừu tượng hóa. Một người dùng đang tương tác với tầng ứng dụng trên cùng.
* **[Speaker Notes]:** "TTầng Ứng dụng chính là bộ mặt của mạng máy tính. Đây là tầng mà chúng ta – những người dùng – có thể nhìn thấy và trực tiếp tương tác mỗi ngày.
Bất kỳ ứng dụng nào bạn đang sử dụng – từ trình duyệt web, ứng dụng gửi email, cho đến trò chơi trực tuyến – đều hoạt động ở tầng này.
Tuy nhiên, để các ứng dụng trên các thiết bị khác nhau có thể “giao tiếp” với nhau qua mạng, chúng phải tuân thủ một tập hợp các quy tắc thống nhất, gọi là các giao thức tầng ứng dụng.
Chính nhờ những giao thức này, mọi ứng dụng trên In-tơ-nét mới hiểu và trao đổi thông tin với nhau một cách chính xác, bất kể chúng được phát triển bởi ai, chạy trên hệ điều hành nào, hay ở đâu trên thế giới."

**Slide 6: Kiến trúc Client/Server**

* **Title:** 1.2. Kiến trúc Phổ biến: Client/Server
* **Content:**
    * **Client:** Là tiến trình **chủ động** khởi tạo liên lạc và yêu cầu dịch vụ. (Ví dụ: Trình duyệt Web của bạn).
    * **Server:** Là tiến trình **bị động**, luôn "lắng nghe" và sẵn sàng đáp ứng các yêu cầu từ Client. (Ví dụ: Web server chứa trang báo).
* **[Visual Idea]:** Một sơ đồ động. Bên trái là một icon Client (laptop) đang gửi đi một "yêu cầu" (request) dạng mũi tên. Bên phải là một icon Server (máy chủ lớn) đang ở trạng thái chờ. Khi mũi tên yêu cầu chạm đến, Server "thức dậy", xử lý và gửi lại một "phản hồi" (response) dạng mũi tên khác về phía Client.
* **[Speaker Notes]:** "Hầu hết các ứng dụng mạng mà chúng ta biết đều được xây dựng dựa trên kiến trúc máy khách - máy chủ.
Hãy hình dung máy khách giống như một khách hàng bước vào cửa hàng. Khách hàng là người chủ động đưa ra yêu cầu, ví dụ: “Tôi muốn mua món hàng này”.
Còn máy chủ chính là người bán hàng, luôn đứng ở quầy, chờ đợi yêu cầu từ khách và sẵn sàng phục vụ khi có yêu cầu đến.
Trong thế giới web, trình duyệt của bạn chính là máy khách, còn máy chủ chứa nội dung trang web là máy chủ. Máy khách gửi yêu cầu truy cập, máy chủ xử lý và gửi lại thông tin — chính nhờ mô hình này mà In-tơ-nét hoạt động hiệu quả và linh hoạt"

**Slide 7: Giao tiếp qua Socket**

* **Title:** 1.3. Socket - "Cánh cửa" của Tiến trình
* **Content:**
    * Là một giao diện lập trình (API) mà ứng dụng sử dụng để gửi và nhận dữ liệu qua mạng.
    * Giống như một "cánh cửa":
        * Ứng dụng "đẩy" thông điệp ra cửa.
        * Hệ điều hành (Tầng Giao vận) ở bên kia cửa sẽ lo việc vận chuyển.
    * Định danh một Socket = **(Địa chỉ IP, Số hiệu Cổng)**.
* **[Visual Idea]:** Một hình ảnh minh họa chi tiết. Một căn phòng lớn tượng trưng cho một tiến trình ứng dụng. Trong căn phòng có một cánh cửa được đánh số (ví dụ: Port 80), có nhãn "Socket". Tiến trình đang đẩy một lá thư (thông điệp) qua khe cửa. Bên ngoài cánh cửa là một người đưa thư (Tầng Giao vận) đang chờ để nhận lá thư và đem đi.
* **[Speaker Notes]:** "Vậy làm thế nào một ứng dụng có thể thực sự gửi dữ liệu ra mạng?
Câu trả lời là: nó không tự làm trực tiếp, mà thông qua một giao diện kết nối mạng, gọi là giao tiếp ổ cắm (hay còn gọi là socket).
Các em hãy hình dung giao tiếp ổ cắm như một cánh cửa kết nối của ứng dụng với thế giới mạng. Khi muốn gửi dữ liệu, ứng dụng chỉ cần đẩy thông điệp qua “cánh cửa” này. Toàn bộ phần việc còn lại — từ đóng gói, truyền đi, kiểm soát — sẽ do hệ điều hành và các tầng mạng bên dưới xử lý.
Mỗi cánh cửa (giao tiếp ổ cắm) này được định danh duy nhất bằng địa chỉ ai-pi của máy và số hiệu cổng của ứng dụng. Nhờ đó, dữ liệu có thể được chuyển đến đúng nơi cần thiết, không bị nhầm lẫn với các ứng dụng khác đang hoạt động cùng lúc trên cùng một thiết bị."

**Slide 8: Giới thiệu HTTP**

* **Title:** 2.1. HTTP - Giao thức của Web
* **Content:**
    * **H**yper**T**ext **T**ransfer **P**rotocol.
    * Sử dụng **TCP** làm nền tảng -> Đảm bảo việc tải trang web là **tin cậy**.
    * Là giao thức **không trạng thái (Stateless)**: Server không lưu lại thông tin về các yêu cầu trước đó của client.
* **[Visual Idea]:** Logo HTTP được đặt ở trung tâm. Từ logo này có các mũi tên chỉ ra 3 đặc điểm chính, mỗi đặc điểm có một icon: một icon TCP, một icon lá chắn tin cậy, và một icon bộ não bị gạch chéo (tượng trưng cho "không nhớ" hay stateless).
* **[Speaker Notes]:** "Bây giờ, chúng ta đến với giao thức quan trọng nhất của Tầng Ứng dụng: ết-ti-ti-pi.
Đây chính là ngôn ngữ mà trình duyệt và máy chủ web sử dụng để “nói chuyện” với nhau. Khi bạn truy cập một trang web, trình duyệt sẽ gửi yêu cầu bằng ết-ti-ti-pi, và máy chủ sẽ phản hồi lại cũng bằng ngôn ngữ này.
Giao thức này được xây dựng trên nền tảng Ti-xi-pi, nên việc tải một trang web luôn được đảm bảo là đầy đủ, đúng thứ tự và không bị lỗi.
Tuy nhiên, có một đặc điểm rất quan trọng của ết-ti-ti-pi: đó là nó “không có trí nhớ”. Nghĩa là: mỗi lần bạn gửi yêu cầu đến máy chủ, máy chủ sẽ xử lý như thể đây là lần đầu tiên nó gặp bạn, không nhớ gì về những yêu cầu trước đó.
Chính tính chất này khiến cho việc quản lý trạng thái (như đăng nhập, giỏ hàng, theo dõi người dùng...) trở thành một thách thức, và cần đến các giải pháp bổ sung như cúc -ki, séc-sừn hoặc tô cừn.."

**Slide 9: Kết nối HTTP Không liên tục**

* **Title:** 2.2. Cách hoạt động cũ: Kết nối không liên tục (Non-Persistent)
* **Content:**
    * Sử dụng trong HTTP 1.0.
    * **Quy trình:**
        1.  Mở kết nối TCP.
        2.  Yêu cầu 1 đối tượng (ví dụ file HTML).
        3.  Nhận đối tượng.
        4.  **Đóng kết nối TCP.**
    * **Vấn đề:** Nếu trang web có 10 hình ảnh, cần phải thực hiện quy trình này **11 lần** -> Rất tốn kém về thời gian và tài nguyên.
* **[Visual Idea]:** Một animation dạng timeline.
    * Client -> Server: Mở TCP.
    * Client -> Server: Yêu cầu file HTML.
    * Server -> Client: Gửi file HTML.
    * Server -> Client: Đóng TCP. (Một vạch đỏ xuất hiện).
    * Quá trình trên lặp lại nhiều lần cho từng file ảnh, mỗi lần đều có bước mở và đóng TCP.
* **[Speaker Notes]:** "Ở phiên bản đầu tiên, ết-ti-ti-pi hoạt động theo kiểu không liên tục.
Điều đó có nghĩa là: cứ mỗi đối tượng trên trang web — như một tệp ết-ti-em-eo, một bức ảnh, hay một đoạn mã — trình duyệt lại phải mở một kết nối Ti-xi-pi mới, tải xong rồi đóng ngay lập tức.
Các em có thể tưởng tượng: nếu một trang web có 1 tệp ết-ti-em-eo và 10 bức ảnh, thì trình duyệt sẽ phải mở và đóng kết nối đến 11 lần.
Điều này gây ra rất nhiều lãng phí về tài nguyên và thời gian, bởi vì việc thiết lập và đóng kết nối Ti-xi-pi là khá tốn kém, đặc biệt khi khoảng cách giữa máy khách và máy chủ là rất xa trong môi trường In-tơ-nét.."

**Slide 10: Kết nối HTTP Liên tục**

* **Title:** 2.3. Cách hoạt động mới: Kết nối liên tục (Persistent)
* **Content:**
    * Chế độ mặc định trong HTTP/1.1 và các phiên bản mới hơn.
    * **Quy trình:**
        1.  Mở kết nối TCP.
        2.  Yêu cầu và nhận nhiều đối tượng qua **cùng một kết nối**.
        3.  Đóng kết nối sau một khoảng thời gian không sử dụng.
    * **Lợi ích:** Nhanh hơn, hiệu quả hơn, giảm tải cho server.
* **[Visual Idea]:** Một animation dạng timeline tương phản.
    * Client -> Server: Mở TCP.
    * Client -> Server: Yêu cầu file HTML.
    * Server -> Client: Gửi file HTML.
    * Client -> Server: Yêu cầu ảnh 1.
    * Server -> Client: Gửi ảnh 1.
    * Client -> Server: Yêu cầu ảnh 2...
    * Tất cả diễn ra trên một đường kết nối TCP duy nhất, chỉ đến cuối cùng đường kết nối mới bị đóng lại.
* **[Speaker Notes]:** "Để khắc phục nhược điểm đó, các phiên bản ết-ti-ti-pi mới hơn sử dụng kết nối liên tục làm mặc định. Bây giờ, trình duyệt sẽ mở một kết nối Ti-xi-pi và giữ nó mở để tải tất cả các đối tượng của trang web. Việc này giống như bạn gọi một cuộc điện thoại và nói hết mọi chuyện cần nói, thay vì cứ mỗi câu lại phải cúp máy gọi lại. Rõ ràng là nó hiệu quả hơn rất nhiều."

**Slide 11: Thông điệp Yêu cầu HTTP**

* **Title:** 2.4. Ngôn ngữ của Client: Thông điệp Yêu cầu (Request)
* **Content:**
    * Là một văn bản thuần túy (ASCII) do trình duyệt tạo ra.
    * **Cấu trúc:**
        * **Dòng yêu cầu:** `Method URL Version` (Ví dụ: `GET /index.html HTTP/1.1`)
        * **Các dòng tiêu đề (Headers):** Cung cấp thông tin bổ sung (`Host`, `User-Agent`...).
        * (Tùy chọn) **Entity Body:** Chứa dữ liệu gửi đi (dùng với phương thức POST).
* **[Visual Idea]:** Một hình ảnh một "lá thư" request được chia thành các phần rõ ràng.
    * Dòng đầu tiên được highlight: `GET /path/to/file.html HTTP/1.1`.
    * Các dòng tiếp theo: `Host: www.example.com`, `User-Agent: Chrome/126.0...`, `Accept-Language: vi-VN`.
    * Một mũi tên chỉ vào `GET` và ghi chú: "Phương thức: Yêu cầu lấy tài nguyên".
* **[Speaker Notes]:** "Đây là một ví dụ về 'lá thư' mà trình duyệt của bạn gửi cho máy chủ. Nó bao gồm một dòng yêu cầu ở đầu tiên, cho biết nó muốn làm gì,  muốn lấy tệp nào, và nó đang sử dụng phiên bản ết-ti-ti-pi  nào. Theo sau là các dòng tiêu đề cung cấp thêm thông tin, ví dụ như tên máy chủ, loại trình duyệt đang dùng, vân vân."

**Slide 12: Thông điệp Trả lời HTTP**

* **Title:** 2.5. Ngôn ngữ của Server: Thông điệp Trả lời (Response)
* **Content:**
    * Cũng là một văn bản thuần túy do server tạo ra.
    * **Cấu trúc:**
        * **Dòng trạng thái:** `Version StatusCode StatusPhrase` (Ví dụ: `HTTP/1.1 200 OK`)
        * **Các dòng tiêu đề:** Cung cấp thông tin về phản hồi (`Content-Type`, `Content-Length`...).
        * **Entity Body:** Chứa đối tượng được yêu cầu (file HTML, ảnh...).
* **[Visual Idea]:** Một hình ảnh một "lá thư" response được chia thành các phần.
    * Dòng đầu tiên được highlight: `HTTP/1.1 200 OK`.
    * Các dòng tiếp theo: `Content-Type: text/html`, `Content-Length: 1234`.
    * Sau một dòng trống là một khối văn bản lớn, ghi `<html>...</html>`, có nhãn là "Entity Body".
    * Một mũi tên chỉ vào `200 OK` và ghi chú: "Mã trạng thái: Yêu cầu thành công!".
* **[Speaker Notes]:** "Và đây là 'thư trả lời' từ máy chủ. Nó cũng có một dòng trạng thái ở đầu, cho biết phiên bản ết-ti-ti-pi và quan trọng nhất là mã trạng thái - kết quả của yêu cầu. Theo sau là các dòng tiêu đề mô tả về dữ liệu được gửi về. Và cuối cùng, phần thân của thư chính là nội dung mà bạn yêu cầu, ví dụ như mã ết-ti-em-eo của trang web."

**Slide 13: Các mã trạng thái HTTP phổ biến**

* **Title:** 2.6. Hiểu các Mã trạng thái (Status Codes)
* **Content:**
    * Là các con số 3 chữ số cho biết kết quả của yêu cầu.
* **[Visual Idea]:** Một infographic dạng 5 thẻ bài, mỗi thẻ cho một mã trạng thái.
    * Thẻ **200 OK**: Màu xanh lá, icon tick ✅. "Mọi thứ đều ổn, đây là nội dung bạn cần."
    * Thẻ **301 Moved Permanently**: Màu xanh dương, icon mũi tên chuyển hướng ↪️. "Thứ bạn tìm đã chuyển nhà sang địa chỉ mới này."
    * Thẻ **400 Bad Request**: Màu vàng, icon dấu chấm than ⚠️. "Yêu cầu của bạn có gì đó sai sai, tôi không hiểu."
    * Thẻ **404 Not Found**: Màu đỏ, icon dấu X ❌. "Tôi đã tìm kỹ rồi nhưng không thấy thứ bạn cần."
    * Thẻ **505 HTTP Version Not Supported**: Màu cam, icon hai phiên bản không khớp 🚫. "Tôi không hiểu ngôn ngữ (phiên bản HTTP) mà bạn đang nói."
* **[Speaker Notes]:** "Những con số này rất quan trọng. Chúng cho trình duyệt biết chính xác điều gì đã xảy ra. 200 có nghĩa là thành công. 301 có nghĩa là tài nguyên đã được chuyển đi nơi khác. Lỗi 404 nổi tiếng có nghĩa là không tìm thấy. Và các mã lỗi 5 ích ích thường chỉ ra vấn đề nằm ở phía máy chủ. Hiểu được chúng giúp chúng ta chẩn đoán lỗi khi duyệt web."

**Slide 14: Giới thiệu HTTPS**

* **Title:** 2.7. HTTPS - Thêm một lớp "Bảo mật"
* **Content:**
    * **H**yper**T**ext **T**ransfer **P**rotocol **S**ecure.
    * Về cơ bản là HTTP, nhưng được chạy trên một kênh **đã mã hóa** bằng **SSL/TLS**.
    * **Đảm bảo:**
        * **Bảo mật:** Dữ liệu không thể bị đọc trộm.
        * **Toàn vẹn:** Dữ liệu không thể bị sửa đổi trên đường đi.
        * **Xác thực:** Bạn đang nói chuyện đúng với máy chủ mà bạn muốn.
* **[Visual Idea]:** Một sơ đồ so sánh.
    * **Bên trên (HTTP):** Một lá thư (request/response) đang được gửi đi trên một con đường công cộng, ai cũng có thể nhìn vào đọc.
    * **Bên dưới (HTTPS):** Một chiếc hộp sắt có khóa (đã mã hóa SSL/TLS) đang được gửi đi trên cùng con đường đó. Không ai có thể nhìn vào bên trong trừ người có chìa khóa. Một icon ổ khóa xuất hiện trên thanh địa chỉ của trình duyệt.
* **[Speaker Notes]:** "Vậy HTTPS là gì? Chữ 'et' ở cuối là viết tắt của Secure - An toàn. Về cơ bản, nó vẫn là giao thức HTTP mà chúng ta vừa học. Nhưng trước khi các thông điệp HTTP được gửi đi, chúng sẽ được mã hóa bằng một lớp bảo mật gọi là SSL hoặc TLS. Điều này đảm bảo rằng không ai có thể đọc trộm hoặc thay đổi nội dung trao đổi giữa bạn và máy chủ. Đây là yếu tố bắt buộc cho mọi giao dịch nhạy cảm trên mạng. Hiện nay hầu hết các web trên thế giới đều phải sử dụng HTTPS"

**Slide 15: Vai trò của DNS**

* **Title:** 3.1. DNS - Giao thức "Phiên dịch"
* **Content:**
    * **D**omain **N**ame **S**ystem.
    * **Nhiệm vụ:** Dịch tên miền mà con người dễ nhớ (`www.google.com`) thành địa chỉ IP mà máy tính hiểu (`172.217.25.196`).
    * Là bước đầu tiên của hầu hết mọi hoạt động trên Internet.
* **[Visual Idea]:** Một sơ đồ "trước" và "sau".
    * **Trước:** Một người dùng đang gãi đầu nhìn vào một dãy số IP, trông rất bối rối.
    * **Sau:** Một icon DNS ở giữa đóng vai trò phiên dịch. Người dùng nói `google.com`, DNS trả về địa chỉ IP cho máy tính. Cả người dùng và máy tính đều vui vẻ.
* **[Speaker Notes]:** "Vậy ết-ti-ti-pi-ét là gì?
Chữ “S” ở cuối viết tắt cho từ An toàn.
Về cơ bản, ết-ti-ti-pi-ét vẫn là giao thức ết-ti-ti-pi mà chúng ta vừa học, nhưng có thêm một lớp bảo vệ. Trước khi các thông điệp được gửi đi, chúng sẽ được mã hóa bằng một lớp bảo mật, giúp đảm bảo rằng không ai có thể đọc trộm hay thay đổi nội dung trao đổi giữa bạn và máy chủ, kể cả khi dữ liệu phải đi qua nhiều thiết bị trung gian trên In-tơ-nét.
Chính nhờ cơ chế này, ết-ti-ti-pi-ét trở thành lựa chọn bắt buộc đối với các hoạt động như đăng nhập, mua sắm, thanh toán trực tuyến, hoặc bất kỳ giao dịch nào đòi hỏi sự riêng tư và an toàn.
Ngày nay, gần như tất cả các trang web trên thế giới đều sử dụng ết-ti-ti-pi-ét để bảo vệ người dùng và dữ liệu khỏi các nguy cơ trên mạng."

**Slide 16: Hệ thống DNS phân cấp**

* **Title:** 3.2. Kiến trúc DNS: Phân tán và Phân cấp
* **Content:**
    * Không có một máy chủ DNS duy nhất nào chứa toàn bộ thông tin.
    * Hệ thống được tổ chức thành một cây phân cấp:
        1.  **Root DNS Servers** (Máy chủ gốc)
        2.  **Top-Level Domain (TLD) Servers** (Máy chủ cho `.com`, `.vn`, `.org`...)
        3.  **Authoritative DNS Servers** (Máy chủ có thẩm quyền cho một tên miền cụ thể, ví dụ `google.com`).
* **[Visual Idea]:** Một sơ đồ hình cây kim tự tháp.
    * Đỉnh kim tự tháp là một icon server ghi "Root Servers".
    * Tầng tiếp theo có nhiều server hơn: `.com` Server, `.org` Server, `.net` Server, `.vn` Server.
    * Tầng đáy có rất nhiều server: `google.com` Server, `microsoft.com` Server, `vnexpress.net` Server.
* **[Speaker Notes]:** "Máy tính giao tiếp với nhau bằng địa chỉ ai-pi, nhưng đối với con người, việc ghi nhớ những dãy số dài và phức tạp này là rất khó khăn.
Chính vì thế, hệ thống phân giải tên miền – gọi tắt là đi-en-ét – đã ra đời để giải quyết vấn đề này.
Các em có thể hình dung đi-en-ét giống như một cuốn danh bạ điện thoại khổng lồ của In-tơ-nét. Bạn chỉ cần gõ tên trang web thì đi-en-ét sẽ tra cứu và trả về địa chỉ ai-pi tương ứng, giống như việc tra tên người trong danh bạ để tìm số điện thoại vậy.
Trên thực tế, hầu hết mọi hoạt động của chúng ta trên mạng, từ duyệt web, gửi thư điện tử, đến chơi game online, đều bắt đầu bằng một truy vấn đi-en-ét. Nhờ đó, máy tính biết phải kết nối đến đâu để thực hiện yêu cầu của bạn."

**Slide 17: Quá trình truy vấn DNS**

* **Title:** 3.3. Hành trình của một Truy vấn DNS
* **Content:**
    * Là một chuỗi các bước hỏi và trả lời để tìm ra địa chỉ IP.
* **[Visual Idea]:** Một animation step-by-step chi tiết (truy vấn tương tác).
    1.  Máy tính của bạn hỏi **Local DNS Server**: "IP của `www.google.com` là gì?"
    2.  Local DNS không biết, nó hỏi **Root Server**.
    3.  Root Server trả lời: "Tôi không biết, nhưng hãy đến hỏi **.com Server**."
    4.  Local DNS hỏi **.com Server**.
    5.  .com Server trả lời: "Tôi không biết, nhưng hãy đến hỏi **Authoritative Server của google.com**."
    6.  Local DNS hỏi **google.com Server**.
    7.  google.com Server trả lời: "Đây là địa chỉ IP: `172.217.25.196`."
    8.  Local DNS trả lời cho máy tính của bạn.
* **[Speaker Notes]:** "Vậy quá trình tra cứu tên miền diễn ra như thế nào? Đó là một chuỗi các bước hỏi – đáp liên tục giữa các máy chủ trong hệ thống Đi-en-ét.
Khi bạn gõ một địa chỉ trang web vào trình duyệt, máy tính của bạn sẽ gửi yêu cầu đến máy chủ Đi-en-ét cục bộ của nhà cung cấp dịch vụ mạng. Nếu máy chủ cục bộ này đã biết địa chỉ, nó sẽ trả lời ngay. Nhưng nếu chưa biết, nó sẽ bắt đầu một hành trình đi tìm câu trả lời – từ gốc đến ngọn trong hệ thống phân cấp.
Đầu tiên, nó sẽ hỏi máy chủ chính. Máy chủ chính sẽ trả lời: “Tôi không biết địa chỉ đó, nhưng bạn hãy hỏi máy chủ quản lý tên miền cấp cao như .com.”
Tiếp theo, máy chủ .com sẽ nói: “Tôi cũng không giữ địa chỉ chi tiết, nhưng bạn nên hỏi máy chủ có thẩm quyền của Google.”
Cuối cùng, máy chủ của Google sẽ trả lời chính xác địa chỉ ai-pi của tên miền cần tìm. Và thông tin này sẽ được gửi ngược trở lại máy tính của bạn.
Tất cả quá trình hỏi – đáp này diễn ra cực kỳ nhanh chóng, chỉ trong vòng vài mili giây, và bạn sẽ thấy trang web hiển thị gần như ngay lập tức. Đây chính là một trong những yếu tố giúp mạng In-tơ-nét hoạt động hiệu quả và liền mạch như chúng ta vẫn thấy hàng ngày."

**Slide 18: Các bản ghi DNS**

* **Title:** 3.4. Các loại Bản ghi DNS (Resource Records)
* **Content:**
    * Là các đơn vị thông tin được lưu trong các máy chủ DNS.
* **[Visual Idea]:** Một bảng biểu đồ họa 4 cột (Name, Value, Type, TTL). Mỗi hàng là một loại bản ghi.
    * **Hàng 1 (Type A):** `(www.google.com, 172.217.25.196, A, ...)` - Một icon máy chủ. "Ánh xạ tên sang địa chỉ IPv4."
    * **Hàng 2 (Type NS):** `(google.com, ns1.google.com, NS, ...)` - Một icon biển chỉ đường. "Chỉ ra ai là máy chủ DNS có thẩm quyền."
    * **Hàng 3 (Type CNAME):** `(mail.google.com, googlemail.com, CNAME, ...)` - Một icon hai cái tên trỏ vào nhau. "Tạo một tên bí danh."
    * **Hàng 4 (Type MX):** `(google.com, aspmx.l.google.com, MX, ...)` - Một icon lá thư. "Chỉ định máy chủ nhận email."
* **[Speaker Notes]:** "Thông tin trong hệ thống Đi-en-ét được lưu trữ dưới dạng các bản ghi, và mỗi bản ghi sẽ đảm nhận một nhiệm vụ cụ thể trong quá trình phân giải tên miền. Có nhiều loại bản ghi khác nhau, mỗi loại phục vụ một mục đích riêng.
Bản ghi loại A là loại phổ biến nhất. Nó dùng để ánh xạ một tên miền cụ thể sang địa chỉ ai-pi tương ứng. Nhờ có bản ghi này, trình duyệt mới biết được cần kết nối đến đâu khi bạn gõ tên một trang web.
Bản ghi NS cho biết máy chủ nào có thẩm quyền quản lý tên miền đó. Khi cần tra cứu thêm thông tin, hệ thống sẽ dựa vào bản ghi NS để chuyển tiếp truy vấn đến đúng nơi.
Bản ghi xi-nêm dùng để tạo ra các tên phụ trỏ về một tên miền chính. Điều này rất hữu ích khi bạn muốn tạo nhiều tên khác nhau cùng trỏ về một máy chủ duy nhất, giúp việc quản lý linh hoạt hơn.
Cuối cùng, bản ghi MX cực kỳ quan trọng đối với dịch vụ thư điện tử. Nó dùng để chỉ định máy chủ nào có trách nhiệm nhận thư điện tử gửi đến tên miền đó. Nếu không có bản ghi MX được cấu hình đúng, các email gửi đến sẽ không thể đến được hộp thư đích.
Việc hiểu rõ các loại bản ghi này là nền tảng để các em có thể thiết lập, quản trị và xử lý sự cố liên quan đến tên miền trong môi trường mạng In-tơ-nét.
"

**Slide 19: Giới thiệu FTP**

* **Title:** 4.1. FTP - Giao thức Truyền tải Tập tin
* **Content:**
    * **F**ile **T**ransfer **P**rotocol.
    * **Nhiệm vụ:** Chuyên dùng để truyền tải file giữa các máy tính.
    * Sử dụng **TCP** để đảm bảo file được truyền đi một cách nguyên vẹn.
    * **Đặc điểm độc đáo:** Sử dụng **HAI kết nối TCP** đồng thời.
* **[Visual Idea]:** Một sơ đồ chi tiết mô tả kiến trúc hai kênh của FTP.
    * Một icon Client và một icon Server được nối với nhau bởi **hai đường riêng biệt**.
    * **Đường thứ nhất:** Một đường nét liền, màu xanh, có nhãn "**Control Connection (Kênh điều khiển) - Port 21**". Trên đường này có các icon nhỏ hình mẩu giấy lệnh (`USER`, `PASS`, `LIST`...). Đường này được thể hiện là tồn tại dai dẳng.
    * **Đường thứ hai:** Một đường nét đứt, màu cam, có nhãn "**Data Connection (Kênh dữ liệu) - Cổng tạm thời**". Trên đường này có một icon file lớn đang di chuyển. Đường này xuất hiện và biến mất sau khi truyền file xong.
* **[Speaker Notes]:** "Tiếp theo, chúng ta sẽ cùng tìm hiểu về Giao thức truyền tệp – hay còn gọi là Ép-Ti-Pi. Đây là một trong những “công nhân chăm chỉ” của thế giới mạng, chuyên thực hiện một nhiệm vụ duy nhất nhưng rất quan trọng: truyền tải tập tin giữa các máy tính qua mạng.
Để đảm bảo dữ liệu được truyền đi một cách đầy đủ, không bị hỏng hoặc mất mát, Ép-Ti-Pi dựa vào giao thức truyền tin đáng tin cậy là Ti-Xi-Pi. Điều này giúp đảm bảo rằng mỗi tập tin đều đến nơi một cách nguyên vẹn, bất kể mạng có gián đoạn trong quá trình truyền tải.
Điểm đặc biệt khiến Ép-Ti-Pi nổi bật so với nhiều giao thức khác là: nó không chỉ sử dụng một mà là hai kết nối Ti-Xi-Pi cùng lúc.
Kết nối thứ nhất gọi là kênh điều khiển, được duy trì liên tục trong suốt phiên làm việc. Kênh này dùng để gửi các mệnh lệnh điều khiển, như yêu cầu đăng nhập, liệt kê danh sách tập tin, tạo thư mục, xóa tập tin,…
Kết nối thứ hai là kênh dữ liệu, chỉ được mở ra khi thực sự cần truyền tải một tập tin cụ thể. Khi việc truyền xong, kênh dữ liệu sẽ được đóng lại. Cách hoạt động này giúp giảm tải cho mạng và tăng hiệu quả truyền thông.
Tóm lại, Ép-Ti-Pi là một công cụ hữu hiệu cho việc chia sẻ và quản lý tập tin từ xa, với thiết kế thông minh để đảm bảo tính an toàn và hiệu quả trong môi trường mạng In-tơ-nét."

**Slide 20: FTP: Chế độ Active vs. Passive**

* **Title:** 4.2. FTP: Chế độ Active vs. Passive
* **Content:**
    * Vấn đề: Ai là người chủ động mở Kênh Dữ liệu?
    * **Active Mode (Chủ động):** Client yêu cầu, nhưng **Server** là người chủ động mở kết nối dữ liệu về phía Client. -> Thường bị firewall của Client chặn.
    * **Passive Mode (Bị động):** Client yêu cầu, Server cung cấp một cổng chờ. **Client** là người chủ động mở kết nối dữ liệu đến Server. -> Thân thiện hơn với firewall.
* **[Visual Idea]:** Một sơ đồ so sánh song song, có hình một bức tường lửa (firewall) ở phía Client.
    * **Panel trái (Active Mode):**
        1. Client gửi lệnh `PORT` đến Server qua kênh điều khiển.
        2. Một mũi tên màu đỏ (kết nối dữ liệu) xuất phát từ Server, cố gắng đi vào Client nhưng bị icon tường lửa chặn lại với dấu X lớn.
    * **Panel phải (Passive Mode):**
        1. Client gửi lệnh `PASV` đến Server.
        2. Server trả lời với một số hiệu cổng.
        3. Một mũi tên màu xanh lá (kết nối dữ liệu) xuất phát từ Client, đi qua tường lửa một cách trót lọt và kết nối đến Server.
* **[Speaker Notes]:** "Một điểm khiến Ép-Ti-Pi trở nên phức tạp hơn so với các giao thức khác chính là cách mà nó mở kênh dữ liệu – đặc biệt là khi phải làm việc qua các thiết bị tường lửa.
Trong chế độ Chủ động , máy khách sẽ nói với máy chủ: “Đây là địa chỉ và cổng của tôi, hãy kết nối về đây để gửi tập tin nhé.” Khi đó, máy chủ sẽ chủ động mở kết nối Ti-Xi-Pi đến địa chỉ của máy khách để truyền dữ liệu.
Tuy nhiên, kiểu kết nối này từ ngoài vào bên trong thường bị tường lửa ở phía máy khách chặn lại, vì hành động đó bị xem là không an toàn.
Để khắc phục tình trạng này, chế độ Thụ động đã ra đời. Trong chế độ này, máy khách sẽ nói với máy chủ: “Bạn có cổng nào trống không? Cho tôi biết để tôi tự kết nối đến.” Máy chủ sẽ chỉ định một cổng sẵn sàng tiếp nhận kết nối và thông báo lại. Sau đó, máy khách chủ động mở kết nối đến cổng đó để truyền dữ liệu.
Vì kết nối này là do máy khách chủ động đi ra, nên thường được tường lửa cho phép, không bị chặn như ở chế độ Chủ động.
Chính vì lý do đó, chế độ Thụ động ngày nay được sử dụng phổ biến hơn, đặc biệt trong các hệ thống mạng có lớp bảo vệ bằng tường lửa hoặc thiết bị định tuyến nghiêm ngặt. Việc hiểu rõ sự khác biệt giữa hai chế độ này là rất quan trọng nếu các em muốn triển khai hoặc xử lý sự cố khi sử dụng Ép-Ti-Pi trong thực tế."

**Slide 21: Hệ thống Email - Các Thành phần**

* **Title:** 5.1. Hệ thống Email - Hoạt động như thế nào?
* **Content:**
    * Bao gồm 3 thành phần chính:
        1.  **User Agent (UA):** Chương trình người dùng (Outlook, Thunderbird, giao diện web của Gmail...). Là nơi đọc, soạn, quản lý thư.
        2.  **Mail Server:** "Bưu cục" của Internet. Lưu trữ hộp thư đến, quản lý hàng đợi thư đi.
        3.  **Các giao thức:** "Ngôn ngữ" giao tiếp giữa các thành phần.
* **[Visual Idea]:** Một infographic tổng quan.
    * Bên trái, một người dùng (An) đang sử dụng một icon User Agent (ví dụ: logo Outlook).
    * Ở giữa là một tòa nhà server lớn có nhãn "Mail Server của An". UA kết nối đến server này.
    * Bên phải là một tòa nhà server khác có nhãn "Mail Server của Bách". Hai tòa nhà server được nối với nhau.
    * Phía trên các đường kết nối là các nhãn giao thức: "POP3/IMAP" cho kết nối UA -> Server, và "SMTP" cho kết nối Server -> Server.
* **[Speaker Notes]:** "Bây giờ chúng ta sẽ khám phá hệ thống email. Nó không đơn giản chỉ là gửi và nhận. Một hệ thống email hoàn chỉnh bao gồm 3 thành phần. User Agent là phần mềm mà bạn dùng để đọc và soạn thư. Mail Server là trái tim của hệ thống, nó giống như một bưu cục, giữ hộp thư của bạn. Và để các thành phần này nói chuyện được với nhau, chúng cần các giao thức, mà chúng ta sẽ tìm hiểu ngay sau đây."

**Slide 22: SMTP - Giao thức "Đẩy" Thư đi**

* **Title:** 5.2. SMTP - Giao thức Gửi thư
* **Content:**
    * **S**imple **M**ail **T**ransfer **P**rotocol.
    * **Nhiệm vụ:** **Gửi (đẩy)** email từ Mail Server này đến Mail Server khác.
    * Là giao thức kiểu **"Đẩy" (Push Protocol)**: Bên gửi chủ động thiết lập kết nối và đẩy dữ liệu lên bên nhận.
    * Sử dụng **TCP**, cổng **25**.
* **[Visual Idea]:** Một animation chi tiết.
    1.  Mail Server A (đóng vai SMTP Client) có một lá thư cần gửi.
    2.  Nó chủ động thiết lập một kết nối TCP đến Port 25 của Mail Server B (SMTP Server).
    3.  Sau khi kết nối được thiết lập, Mail Server A "đẩy" lá thư qua đường kết nối này cho Mail Server B. Mũi tên di chuyển của lá thư đi rõ ràng từ A sang B.
* **[Speaker Notes]:** "Khi bạn nhấn nút 'Gửi', giao thức SMTP sẽ vào cuộc. Nhiệm vụ của nó là vận chuyển lá thư của bạn từ máy chủ mail của bạn đến máy chủ mail của người nhận. SMTP được gọi là giao thức 'đẩy', vì chính máy chủ gửi là người chủ động thiết lập kết nối và 'đẩy' lá thư đi. Nó sử dụng TCP để đảm bảo lá thư được chuyển đi một cách tin cậy."

**Slide 23: Giao thức "Kéo" Thư về**

* **Title:** 5.3. Nhận thư: Giao thức Truy cập Mail
* **Content:**
    * SMTP chỉ giao thư đến Mail Server. Làm thế nào để User Agent lấy thư từ server về máy?
    * Cần một giao thức kiểu **"Kéo" (Pull Protocol)**.
    * Hai giao thức phổ biến: **POP3** và **IMAP**.
* **[Visual Idea]:** Một sơ đồ rõ ràng. Một icon Mail Server lớn chứa đầy các lá thư. Một icon User Agent (laptop) ở xa. Một mũi tên lớn có nhãn "PULL" xuất phát từ User Agent, "kéo" các lá thư từ Mail Server về phía nó. Bên cạnh mũi tên có hai logo nhỏ: POP3 và IMAP.
* **[Speaker Notes]:** "SMTP chỉ làm một nửa công việc: giao thư đến bưu điện của người nhận. Bây giờ, người nhận cần phải ra bưu điện để lấy thư về. Hành động này cần một giao thức 'kéo'. User Agent của người dùng sẽ chủ động kết nối đến Mail Server và 'kéo' các email mới về. Có hai giao thức phổ biến để làm việc này là POP3 và IMAP."

**Slide 24: So sánh POP3 và IMAP**

* **Title:** 5.4. Lựa chọn cách nhận thư: POP3 vs. IMAP
* **Content:**
    * So sánh hai phương pháp truy cập mail phổ biến.
* **[Visual Idea]:** Một bảng so sánh chi tiết, trực quan với 2 cột.
    * **Cột POP3 (Post Office Protocol 3):**
        * Icon: Một hòm thư đơn giản.
        * Đặc điểm: Đơn giản, ít chức năng.
        * Hoạt động: Thường là "Tải về và Xóa" (Download and delete). Email được chuyển hẳn về máy client.
        * Trạng thái: Không đồng bộ. Thư đã đọc trên máy này sẽ hiện là chưa đọc trên máy khác.
        * Phù hợp: Người dùng chỉ sử dụng email trên một thiết bị duy nhất.
    * **Cột IMAP (Internet Mail Access Protocol):**
        * Icon: Một đám mây đồng bộ với nhiều thiết bị (laptop, điện thoại).
        * Đặc điểm: Phức tạp, nhiều tính năng.
        * Hoạt động: Thao tác trực tiếp trên server. Giữ mail trên server.
        * Trạng thái: Đồng bộ hóa hoàn toàn. Đọc thư trên điện thoại, laptop cũng sẽ thấy thư đã được đọc. Cho phép quản lý thư mục trên server.
        * Phù hợp: Người dùng truy cập email từ nhiều thiết bị khác nhau.
* **[Speaker Notes]:** "pi-ô-pi phiên bản 3 và ai-MAP cung cấp hai triết lý hoàn toàn khác nhau. pi-ô-pi 3 , giống như việc bạn ra bưu điện lấy hết thư về nhà, sau đó hòm thư ở bưu điện sẽ trống rỗng. Nó đơn giản, nhưng nếu bạn muốn đọc lại thư từ một máy khác thì không được. Ngược lại, ai-MAP giống như bạn chỉ xem thư ngay tại bưu điện. Mọi thứ, từ việc sắp xếp thư vào các ngăn tủ khác nhau, đến việc đánh dấu thư đã đọc, đều được thực hiện và lưu lại ngay tại bưu điện (tương đương với máy chủ). Điều này cho phép bạn truy cập và thấy cùng một trạng thái hộp thư từ bất kỳ thiết bị nào."

**Slide 25: Webmail - Phương pháp hiện đại**

* **Title:** 5.5. Webmail (Gmail, Outlook.com)
* **Content:**
    * Sử dụng trình duyệt Web làm User Agent.
    * Giao thức được sử dụng giữa trình duyệt và Mail Server là **HTTP/HTTPS**.
    * SMTP vẫn được sử dụng để gửi thư giữa các Mail Server trong hậu trường.
* **[Visual Idea]:** Một sơ đồ luồng chi tiết.
    1.  Người dùng sử dụng icon trình duyệt Chrome.
    2.  Một đường kết nối có nhãn "**HTTPS**" nối Chrome với một server lớn có logo Gmail.
    3.  Từ server Gmail này, một đường kết nối khác có nhãn "**SMTP**" nối đến một Mail Server khác (ví dụ: của một công ty).
    Sơ đồ nhấn mạnh rằng người dùng chỉ tương tác qua HTTP, còn SMTP là việc của các server nói chuyện với nhau.
* **[Speaker Notes]:** "Phương pháp phổ biến nhất ngày nay để sử dụng thư điện tử là thư web, ví dụ như dịch vụ của Gmail. Khi bạn sử dụng Gmail, trình duyệt web trên máy tính hoặc điện thoại chính là phần mềm người dùng, cho phép bạn soạn, đọc và gửi thư.
Toàn bộ quá trình trao đổi giữa bạn và máy chủ thư của Google được thực hiện thông qua giao thức truyền thông qua trang web, thường là giao thức truyền siêu văn bản. Khác với các phương pháp truyền thống dùng giao thức truy xuất thư hay giao thức truy xuất thư trên mạng, hình thức thư web không cần phần mềm thư riêng biệt cài đặt trên máy.
Tuy nhiên, khi bạn gửi một bức thư từ Gmail đến một địa chỉ thuộc một công ty khác, thì ở phía sau, máy chủ của Google vẫn sử dụng giao thức chuyển thư đơn giản để chuyển tiếp thư đi như bình thường. Giao thức này là phần không thể thiếu trong quá trình phân phối thư giữa các máy chủ trên mạng In-tơ-nét."

**Slide 26: Giải quyết tình huống**

* **Title:** Giải mã tình huống
* **Content:**
    * Một chuỗi các hành động đơn giản nhưng sử dụng nhiều giao thức phức tạp.
* **[Visual Idea]:** Một infographic tổng hợp dạng flowchart, đi theo hành trình của An.
    1.  **Hành động:** An gõ `mail.google.com`. -> **Giao thức:** **DNS** được kích hoạt để tìm địa chỉ IP.
    2.  **Hành động:** Giao diện Gmail hiện ra. An đăng nhập, soạn thư. -> **Giao thức:** **HTTPS** được sử dụng để trao đổi thông tin an toàn giữa trình duyệt và server Google.
    3.  **Hành động:** An nhấn "Gửi". -> **Giao thức:** **HTTPS** gửi lệnh và nội dung thư lên server Google. Server Google sau đó dùng **SMTP** để đẩy thư đến server của giáo viên.
    4.  **Hành động:** Giáo viên nhận thư. -> **Giao thức:** **POP3/IMAP/HTTPS** được dùng để "kéo" thư về máy hoặc trình duyệt của giáo viên.
* **[Speaker Notes]:** "Bây giờ, chúng ta đã có thể giải mã hoàn toàn tình huống của An – một ví dụ điển hình cho sự phối hợp nhịp nhàng giữa các giao thức trong mạng In-tơ-nét.
Khi An gõ địa chỉ trang web vào trình duyệt, hệ thống phân giải tên miền (Đi-en-ét) sẽ làm việc, giúp tìm ra địa chỉ ai-pi của máy chủ Gmail.
Khi An bắt đầu tương tác với giao diện Gmail trên trình duyệt, từ việc soạn thư đến nhấn nút gửi, giao thức truyền siêu văn bản có bảo mật sẽ đảm nhận vai trò đảm bảo dữ liệu được truyền đi an toàn và mã hóa giữa trình duyệt và máy chủ của Google.
Khi An nhấn nút gửi thư, giao thức truyền siêu văn bản có bảo mật sẽ thông báo đến máy chủ thư. Sau đó, máy chủ của Google sẽ sử dụng giao thức chuyển thư đơn giản để gửi thư đi tới máy chủ đích, theo đúng địa chỉ thư điện tử của người nhận.
Cuối cùng, giáo viên của An – người nhận thư – sẽ dùng một trong các giao thức truy xuất thư để lấy thư từ máy chủ về thiết bị của mình, có thể là giao thức truy xuất thư hoặc giao thức truy xuất thư trên mạng, tùy theo cách thiết lập.
Một quá trình tưởng chừng đơn giản nhưng thực chất là một bản giao hưởng tinh tế giữa các giao thức ở tầng ứng dụng, cùng phối hợp để đảm bảo thư của An được gửi đi trọn vẹn, an toàn và đến đúng nơi."

**Slide 27: Tóm tắt Tầng Ứng dụng**

* **Title:** Tóm tắt những điểm cốt lõi
* **Content:**
    * **HTTP:** Giao thức "kéo", không trạng thái, nền tảng của Web.
    * **DNS:** Hệ thống "danh bạ" phân cấp của Internet.
    * **FTP:** Chuyên gia truyền file với kiến trúc 2 kênh TCP.
    * **Email:** Sử dụng **SMTP** để "đẩy" thư đi và **POP3/IMAP** để "kéo" thư về.
* **[Visual Idea]:** Một slide dạng dashboard với 4 widget. Mỗi widget dành cho một nhóm giao thức, có logo, tên và 2-3 từ khóa mô tả bản chất của nó (ví dụ: HTTP -> Kéo, Stateless; SMTP -> Đẩy, Tin cậy).
* **[Speaker Notes]:** "Để tổng kết lại bài học cuối cùng này, các em hãy nhớ những bản chất cốt lõi: ết-ti-ti-pi là giao thức kéo cho web. Đi-en-ét là danh bạ. Ép-ti-pi dùng hai kênh để truyền tệp. Và i-mêu là sự kết hợp của giao thức đẩy ét-em-ti-po và các giao thức kéo như pi-ô-pi3 và ai-MAP."

**Slide 28: Câu hỏi ôn tập**

* **Title:** Câu hỏi ôn tập & thảo luận
* **Content:**
    1.  So sánh và chỉ ra sự khác biệt cơ bản trong cách HTTP và FTP sử dụng các kết nối TCP. Tại sao FTP lại cần một kênh riêng cho dữ liệu?
    2.  Phân tích ưu và nhược điểm của việc dùng Outlook (POP3/IMAP) so với dùng Webmail (HTTP) để quản lý email công việc.
    3.  Khi thiết kế một ứng dụng mới, yếu tố nào quyết định việc bạn xây dựng giao thức của mình trên nền TCP hay UDP?
* **[Visual Idea]:** Một hình ảnh một bộ não lớn đang phát sáng, xung quanh là các icon liên quan đến 3 câu hỏi: một icon so sánh HTTP/FTP, một icon Outlook và Gmail, và một icon lựa chọn giữa TCP/UDP.
* **[Speaker Notes]:** "Để củng cố kiến thức, thầy có 3 câu hỏi mở để các em về nhà suy nghĩ. Những câu hỏi này không chỉ là về kỹ thuật, mà còn về thiết kế hệ thống và lựa chọn giải pháp. Hãy suy nghĩ và trả lời trên hệ thống học tập nhé."

**Slide 29: Kết thúc Môn học**

* **Title:** KẾT THÚC HÀNH TRÌNH
* **Subtitle:** Thank you!
* **[Visual Idea]:** Một animation cuối cùng, hoành tráng. Bắt đầu từ một bit 0/1 ở tầng vật lý, nó được đóng gói thành frame ở tầng 2, rồi thành packet ở tầng 3, thành segment ở tầng 4, và cuối cùng trở thành một phần của trang web (logo HTTP) hiển thị trên màn hình ở tầng 7. Dòng chữ "Cảm ơn các em đã đồng hành!" xuất hiện ở cuối.
* **[Speaker Notes]:** "Vậy là chúng ta đã hoàn thành hành trình khám phá các tầng của mô hình mạng. Bắt đầu từ những tín hiệu điện, đi qua các khung dữ liệu, các gói tin, các phân đoạn, và cuối cùng là các thông điệp của Tầng Ứng dụng, các em đã có một nền tảng vững chắc về cách in-tơ-nét hoạt động. Thầy hy vọng môn học đã cung cấp cho các em một bộ khung kiến thức hữu ích để tiếp tục khám phá những lĩnh vực chuyên sâu hơn. Cảm ơn sự tham gia và nỗ lực của tất cả các em trong suốt học kỳ qua."